# 이전 작동 시기에 K 광년 이동 시 K-1, K, K+1 광년 만을 다시 이동할 수 있다.
# 중간 값이 가장 큰 값이고, 피라미드 형식으로 Kn 이 결정되어야 한다.

import sys

for _ in range(int(sys.stdin.readline().strip())):
    x, y = map(int, sys.stdin.readline().split())

    dist, move = y-x, 0
    # s = dist ** 0.5
    # move = 2 * s - 1 if s ** 2 == dist else 2 * s
    # if dist >= s * (s+1):
    #     move += 1
    # print(int(move))
    cnt = 0
    moving = 0
    while move < dist:
        cnt += 1
        if cnt % 2 != 0:
            moving += 1
        move += moving
        print(cnt, move, moving)
    print(cnt)


"""
m=y-x
int((4*m-1)**0.5)
계산해 보면 홀수 번(2k-1)번 이동할 때는 최대 k^2, 짝수 번(2k) 이동할 때는 k^2+k가 이동할 수 있는 최대 거리가 됩니다.
따라서 k^2-k < m <= k^2일 때 2k-1, k^2<m<=k^2+k일 때 2k을 반환 하는 함수 f(m)을 구하면 그게 곧 답이 되는데, 위 식은 그 중의 하나 입니다.

각 제곱 수를 지날 때마다 이동 횟수가 1씩 추가되고, 두 제곱 수의 중간값을 지날 때에도 이동 횟수가 1씩 추가되는 것을 확인할 수 있었다. 그럼 이제 두 패턴을 기반으로 코드를 구현해주면 된다.

1. 제곱근 구하기
해당 이동거리가 제곱 수인지 아닌지를 체크하기 위해 제곱근을 먼저 구해주고, 이를 이동 횟수 계산에서 이용한다.

2. 제곱 수일 경우
패턴을 보면 제곱 수를 지났을 때 이동 횟수는 제곱근 * 2가 되는 것을 알 수 있다. 즉 제곱 수를 지나지 않았을 때에는 (이동 거리가 제곱 수인 경우) 제곱근 * 2 - 1이 된다.

ex)
4(2^2) -> 3 (2 * 2 - 1)
5(2^2 + 1) -> 4 (2 * 2)
6(2^2 + 2) -> 4 (2 * 2)

9(3^3) -> 5 (2 * 3 - 1)
10 (3^3 + 1) -> 6 (2 * 3)
11 (3^3 + 2) -> 6 (2 * 3)

3. 두 제곱 수의 중간값을 지났을 경우
두 제곱 수의 중간값을 지났을 때 이동 횟수는 제곱근 * 2 + 1이 되는 것을 알 수 있다. 이때 두 제곱 수의 중간값은 제곱근^2 + 제곱근으로 표현할 수 있다. 따라서 조건문을 추가하여 이를 구현해주었다.

ex)
6 (2^2 + 2) -> 4 (2 * 2)
7 (2^2 + 3) -> 5 (2 * 2 + 1)

12 (3^3 + 3) -> 6 (2 * 3)
13 (3^3 + 4) -> 7 (2 * 3 + 1)

    1 - 1
    2 - 2
    3 - 3
    4 - 3  | 1 2 1
    5 - 4  | 1 2 1 1
    6 - 4  | 1 2 2 1
    7 - 5  | 1 2 2 1 1
    8 - 5  | 1 2 2 2 1
    9 - 5  | 1 2 3 2 1
    10 - 6 | 1 2 3 2 1 1
    11 - 6 | 1 2 3 2 2 1
    12 - 6 | 1 2 3 3 2 1
    13 - 7 | 1 2 3 3 2 1 1
    14 - 7 | 1 2 3 3 2 2 1
    15 - 7 | 1 2 3 3 3 2 1
    16 - 7 | 1 2 3 4 3 2 1
    17 - 8 | 1 2 3 4 3 2 1 1
"""